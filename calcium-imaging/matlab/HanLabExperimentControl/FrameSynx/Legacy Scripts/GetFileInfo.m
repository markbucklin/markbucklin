%   function GetFileInfo
%
%   Extracts timing info for messages. Combines with info about eye, pupil, and image frame times to generate the following:
%
%       time_trace:         Array of trial #s, eye positions, pupil radius, etc (SEE time_labels) for each time sample point from BehavCtrl:
%                           eye_x, eye_y, eye_r, eye_t: eye x, y, pupil size & sample time from eye trace
%                           trial, outcome: trial number & outcome (correct
%                           = 0; from BehavCtrl)
%                           frame: image frame number: marking the eye sample time closest to the start of each image frame, on up to the start of the next
%       frame_trace:        Array of trial #s, frame means, etc (SEE frame_labels) for each frame stored in ContImg
%                           trial: trial number, as registered in UDP synch 4 for each image frame
%                           stim: stim number, (UDP synch 2)
%                           mean: overall mean of entire image frame
%                           outcome: (correct = 0): as obtained from BehavCtrl for the corresponding trial #
%                           time: time of frame midpoint, corrected for alignment of ContImage & BehavCtrl clocks (aligned on trial transitions = StartTimes)
%       time_event_trace:   Event messages generated by BehavCtrl, at the resolution of the sample rate within BehavCtrl
%       frame_event_trace:  Event message, but now aligned to the corresponding image frame, corrected for time_frame misalignment
%       FileInfo:           File-by-file listing of useful information (start & end times, message events, etc) See FILE_INFO struct
%
%       NOTE: Image frame times are aligned to corresponding event times by the midpoint of the frame.
%
%   Aug 14 2006: in the event_trace entries, instead of just '1' give the time stamp in frame_event_trace & the frame stamp in time_event_trace
%   Aug 22 2006: added StimType to FileInfo struct; added StimTypes & UniqueStimuli to HEADER
%   Aug 23 2006: added 2 extra lines to the events: 'DurStimON' and 'DurStimSHIFT'. Duration of Stim ON & Stim Shift filled with UDP Stim synch. 
%       NOTE: default = -1 rather than 0 (to allow Stim 0)
%
%   Can run in any directory. Needs to extract information from SYNCH.mat, .bhv & .eye files. 
%   Binds the info to the corresponding image files (incorporating Gene's bindBhvToImg). ... AUG 22 2006: binding is NO LONGER the default
%
%   Sep 15 2006: Making the program backwards compatible with episodic recording (ValMatFormat = 1): Cobbled together the different files to 
%       simulate a continuous recording: artificially chose the next trial start time = current trial start time + duration of current trial
%       as calculated from the Frame Arrival Times. Get 'StartTimeGlue' to glue trials together.
%       Actual start & stop times stored separately. 
%
%   Dec 9 2006: Corrected a 1-frame mismatch that I had from the start of the 'alignment' process.
%
%   Dec 14 2006: Started Val_MatFormat = 3: Red / Grn interleaved.
%   Dec 20 2006: Made Val_MatFormat = 3 the default. Expand frame_trace to start keeping mean1 and mean2 simultaneously. Make '1' (red / Hb)
%       the standard & fill in the green (2) since frames and time stamps are so similar between the two. 
%   NOTE: Assume that SYNCH file name is of the form e.g. VOX2_1_?????_SYNCH.mat etc where the important part is 'VOX2_1_
%   
%   e.g. GetFileInfo('ValMatFormat', 1, 'flnmFormat', 'VOX1_0*.mat');

%   Mar 01 2008: Start adding in spike data. Include both in eye trace bins (spikeT) & frame trace bins (spikeF)
%       Start with Val_MatFormat = 2.2 (single color) but also write mod for Val_MatFormat = 3.2 (same, R & G).
%   NOTE: also started reading in heart rate using Gene's script & storing in the frame_trace

%   Mar 10 2008: Generalize the process of reading in synch files, pupil data etc so no need to repeat code with new wavelength
%       So, e.g. test for presence of multiple synch files & name mean, meanFltr accordingly

%   Mar 15 2008: Got rid of Val_MatFormat = 1; For that, use earlier versions
%       Everything else: default Val_MatFormat = 0. Only value of 2 special, because no pupil data

%   Mar 31 2008: Rewrote to be able to use in BATCH process. Format:
%           GetFileInfo('rootFlnm','STR1') .... with electrode data
%           GetFileInfo('rootFlnm','STR2','hasPlx','no') .... with no electrode data
%   Typically (but NOT NECESSARILY) run from directory with img files
%   Expects SYNCH, plx & bhv files in default directories: ..\, ..\plx\ & ..\bhv\ respectively. If not, specify.
%
%   Jul 8 2008: Added Val_MatFormat = 4; Breathing trace. YBS.
%
function [FileInfo, time_trace, frame_trace, time_event_trace, frame_event_trace, HEADER] = GetFileInfo(varargin)

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INIT %%%%%%

dirFileInfo = '../';         % Directory where ...FileInfo.mat is stored
dirImgFiles = './';         % By default, open in directory where files are stored
BindToFile = 0;                 % By default, DO NOT bind to files.
synchFile = '';  % Remember to enter full directory name, if not in the parent dir. Also, full name. NOT RELEVANT for ValMatFormat < 2
existsFlnmFormat = 0;
Val_MatFormat = 0;              % 0=Undefined; 1=trial-wise recordings; 2=continuous, but NO eyeR data; 
NWvLngths = 1;                % Number of distinct wavelengths (e.g. 2 for 605=1 + 530=2) 
bhvFile = '';
plxFile = ''; % the plexon data file
bhvPath = '../Bhv/';
plxPath = '../Plx/';
synchPath = '../';
rootFlnm = '';              % eg 'STR3' ... used to look for synch, bhv, plx files
hasPlx = 'Yes';                 % Default: plexon data present, look for plx file. If not, enter 0

for n = 1:2:length(varargin)
    switch varargin{n}
    case 'dirFileInfo'
        dirFileInfo = varargin{n+1};
    case 'dirImageFiles'
        dirImageFiles = varargin{n+1};
    case 'BindToFile'
        BindToFile = varargin{n+1};
    case 'synchFile'
        synchFile = varargin{n+1};
    case 'Val_MatFormat'
        Val_MatFormat = varargin{n+1};
    case 'flnmFormat'
        flnmFormat = varargin{n+1};
        existsFlnmFormat = 1;
    case 'bhvFile'
        bhvFile = varargin{n+1};
    case 'plxFile'
        plxFile = varargin{n+1};
    case 'bhvPath'
        bhvPath = varargin{n+1};
    case 'plxPath'
        plxPath = varargin{n+1};
    case 'synchPath'
        synchPath = varargin{n+1};
    case 'rootFlnm'
        rootFlnm = varargin{n+1};
    case 'hasPlx'
        hasPlx = varargin{n+1};
    otherwise
        error([mfilename ': Unknown parameter ' varargin{n}]);
    end
end

if isempty(rootFlnm)    % Get file names interactively
    if size(dir([bhvPath bhvFile]),1) ~= 1
        [bhvFile,bhvPath] = uigetfile('*.bhv','Pick a BHV file...');
%         bhvFile = [bhvPath bhvFile];
    end
    if size(dir([synchPath synchFile]),1)~=1   % For batch processing, see if pre-specificied file exists
        [synchFile,synchPath] = uigetfile('*.mat','Pick a SYNCH file...');
    end
    if strcmpi('yes',hasPlx) &&  (size(dir([plxPath plxFile]),1) ~= 1)
       hasPlx = questdlg('Include PLX file?','Include PLX file?','Yes','No','No');
       switch hasPlx
           case 'Yes'
               [plxFile,plxPath] = uigetfile('*.plx','Pick a PLX file...');
       end
    end
else
    if isempty(bhvFile);   
        bhvFile = dir([bhvPath rootFlnm '*.bhv']);   
        if size(bhvFile,1) == 1;  bhvFile = bhvFile(1).name;
        else
            disp('No valid BHV file?'); keyboard;
        end
    end
    if (isempty(plxFile) && strcmpi('yes', hasPlx));   
        plxFile = dir([plxPath rootFlnm '*.plx']);   
        if size(plxFile,1) == 1;  plxFile = plxFile(1).name;
        else
            disp('******************');
            disp('No valid PLX file?'); 
            disp('******************');
            hasPlx = 'No';
        end
    end
    if isempty(synchFile);  
        synchFile = dir([synchPath rootFlnm '*_SYNCH.mat']);
        if size(synchFile,1) >= 1;   synchFile = synchFile(1).name;      % to get one of e.g. STR1_1_*_SYNCH.mat, STR1_2_*_SYNCH.mat
        else
            disp('No valid SYNCH file?'); keyboard;
        end
    end
           
end

% keyboard

% YBS moved to beginning to get eye file from header
[header,trials] = readBhvFile([bhvPath bhvFile]);
eyeFile = [bhvPath header.EyeDataFileName];
% eyeFile = [bhvFile(1:end-3) 'bhv'];
if exist(eyeFile,'file')~=2
    error(sprintf('%s: File %s not found',mfilename,[bhvPath eyeFile])); 
end

% AD: read in synch files, in multiple sequence. All except non-continuous early recordings
% Assume synch file naming convention e.g. STR2_1_00104_00104_SYNCH.mat, STR2_2_00104_00104_SYNCH.mat
% Set the first one ('Red') as the master & trim others to it.
[synchFileAry fileSequence frameSynch frameArrivalTime nWvLngths synchFlLbl FlnmAry] = getSynchFileInfo(synchPath, synchFile);
NumTrials = length(fileSequence);    % %%%%%%%%%%%%%%%%%%%%%%%%%%% NUMBER OF TRIALS (= FILES). 
FramePer = mean(diff(frameArrivalTime));    %%%%%%%%% MEAN FRAME PERIOD 

% YBS: reading PLX spike data files. Mar 01 2008
if strcmpi('yes', hasPlx)
    [plxHeader,plxData] = readPlxFile([plxPath plxFile]);
end

% keyboard
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Set up structs, buffers etc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if (Val_MatFormat == 2)    % Prior to gathering eyeR data. Need to specify for reading .eye files
    time_labels = {'eye_x','eye_y','eye_t','trial', 'outcome', 'frame'};
elseif (Val_MatFormat<4)
    time_labels = {'eye_x','eye_y','eye_r','eye_t','trial', 'outcome', 'frame'};
elseif (Val_MatFormat>=4)
    time_labels = {'eye_x','eye_y','eye_r','breath','eye_t','trial', 'outcome', 'frame'};
end
frame_labels = {'trial', 'stim', 'outcome', 'time', 'tBin', 'HR', 'HR_Fltr'};

% Add space for spike times at tBin binning (spikeT) & frame binning (spikeF), plus their runline filtered versions
if strcmpi('yes', hasPlx)
    Lt = size(time_labels,2); time_labels{Lt+1} = 'spikeT'; time_labels{Lt+2}= 'spikeT_Fltr';
    Lf = size(frame_labels,2); frame_labels{Lf+1} = 'spikeF'; frame_labels{Lf+2}= 'spikeF_Fltr';
end

% Add space for all wavelength traces & their runline filtered versions
for i=1:nWvLngths
    Lf = size(frame_labels,2); frame_labels{Lf+1} = ['mean' synchFlLbl{i}]; frame_labels{Lf+2} = ['mean' synchFlLbl{i} '_Fltr'];
end
    
StimTypes = {'STIMULUS_IMAGE', 'STIMULUS_MOVIE', 'STIMULUS_GRATING','STIMULUS_ANNULAR','STIMULUS_PAIR','STIMULUS_TRIPLET','STIMULUS_BLANK'};       % All possible classes of stimuli created 

FILE_INFO = struct(...
    'name', 'char[240]', ... 
    'name1', 'char[240]', ... 
    'name2', 'char[240]', ... 
    'FileIndex', NaN, ...       % Needed to account for "trials" with lever pulls that don't trigger trial files.
    'TrialIndex', NaN, ...
    'GlobalTrialNum', NaN,...
    'first_frame', NaN, ...
    'last_frame', NaN, ...
    'NFrames', NaN, ...
    'Stim', [], ...         % stim struct carrying all stimulus info
    'StimType', [], ...
    'BitmapStim', [], ...
    'GratingOrientation', 'double', ...
    'Outcome', NaN,...
    'NEvents', NaN,...
    'StartTime', NaN, ...
    'EndTime', NaN, ...
    'StartTimeActual', NaN, ... % For episodic, where the trials are cobbled together to give "continuous" stream
    'EndTimeActual', NaN, ...
    'MsgEvents', [], ...    % Array of all msg events
    'MsgTimes', [], ...      % Array of all msg times
    'TFixPeriodOn', NaN, ...
    'TStimOn', NaN, ...      % Cumulatively from the start of the session.
    'TStimShift', NaN, ...
    'TStimOff', NaN, ...
    'TStartReward', NaN, ...
    'UDP_StimFrames', [], ...   % UDP synch channel 2 in frames relative to start of trial
    'UDP_TimeArrivalMSec', [], ... % Holdover from earlier Val_MatFormats. NOTE: convert to MILLISECONDS from MICROSECONDS
    'MsgFrames', [], ...  % All Msg event times, in units of image frames WITH ALIGNMENT / CORRECTION
    'MsgTimeBin', [], ...   % All Msg event times, rounded off to nearest eye-trace time sample bin (corrected for non-zero T intercept)
    'FrameFixPeriodOn', NaN, ...    % Selected Msg events in units of aligned frames - both absolute & relative;
    'FrameStimOn', NaN, ...
    'FrameStimShift', NaN, ...
    'FrameStimOff', NaN, ...
    'FrameFixPeriodOnRel', NaN, ... 
    'FrameStimOnRel', NaN, ...
    'FrameStimShiftRel', NaN, ...
    'FrameStimOffRel', NaN,...
    'TBin_StartTime', NaN, ...
    'TBin_EndTime', NaN, ...
    'TBin_FixOn', NaN, ...
    'TBin_StimOn', NaN, ...
    'TBin_StimShift', NaN, ...
    'TBin_StimOff', NaN, ...
    'TBin_StartReward', NaN ...
); 

HEADER = struct(...
    'Val_MatFormat', NaN, ...
    'DateTime', 'char[50]', ...
    'Time0', NaN, ...               % Actual start time of first trial
    'ExperimentName', 'char[50]', ...
    'StimTypes', [], ...                % All stim types present in current expt.
    'UniqueStimuli', [], ...
    'UniqueUDP_Stim', [], ...
    'NumTrials', NaN, ...
    'FirstTrialNum', NaN, ...
    'FramePer', NaN, ...
    'FrameFreq', NaN, ...
    'TimePer', NaN, ...
    'TimeSampleFreq', NaN, ...
    'Frame_TimeRatio', NaN, ...
    'Time_Frame_Mismatch', NaN, ...         % Dec 9 2006: Start counting mismatch from CENTRE of corr frame
    'Time_TimeBinConversion', 'char[100]', ...
    'Time_FrameBinConversion', 'char[100]', ...
    'T_Intercept', NaN, ...
    'time_labels', [], ...      
    'frame_labels', [], ...
    'event_labels', [] ...
    );

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start filling the fields of FileInfo. Get MEAN FRAME PERIOD, total NUMBER OF TRIALS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

HEADER.Val_MatFormat = Val_MatFormat;

% Get full set of global trial indices, since Val_MatFormat 1 trials only converted correct trials, not all in the "trial" struct seq
TrialAry = zeros(1,length(trials));
for i=1:length(TrialAry)
    TrialAry(i) = trials(i).head.TrialNumber;
end

FileInfo = repmat(FILE_INFO, NumTrials, 1);

HEADER.FirstTrialNum = trials(1).head.TrialNumber;
HEADER.DateTime = header.DateTimeRecorded;
HEADER.ExperimentName = header.ExperimentName;
HEADER.time_labels = time_labels;
HEADER.frame_labels = frame_labels;
HEADER.SynchFiles = synchFileAry;
HEADER.SynchFileLabels = synchFlLbl;

% Diary with the day's date
DiaryFlnm = strcat(dirFileInfo, '/', HEADER.ExperimentName, '_FileInfolog_', date, '.dat');
diary(DiaryFlnm);
fprintf('\nExtracting info from BehavFiles: %s, EyeFile: %s\n', bhvFile, eyeFile);

disp('Filling FileInfo with BehavCtrl message info & ContImage synch info');
StimTypeFlg = 0;    % 1: bitmaps; 
CumFrames = 1;  % Cumulative count of frames. Necessary for episodic trials, to cobble together artificially into continuous trace
CumFramePer = zeros(NumTrials,2); % To get average frame rate; 1: value of average period for a trial, 2: # of frames in that average
StartTimeGlue = zeros(1,NumTrials);     % Glue to stick the different trials together
FileInfoErrorFlg = 0;

for i_File=1:NumTrials
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    % Get frame timing info (getting it early to set correction factor for message times) 
    for i=1:nWvLngths; eval(['FileInfo(i_File).name' synchFlLbl{i} ' = FlnmAry{i}{i_File};']);  end
    FileInfo(i_File).FileIndex = i_File;
    FileInfo(i_File).first_frame = fileSequence(i_File).first_frame;
    FileInfo(i_File).last_frame = fileSequence(i_File).last_frame;
            i_Trial = i_File; 

    FileInfo(i_File).Stim = trials(i_Trial).stim;

    % Necessary to have this check because sometimes the last image file is incorrectly entered as having no last_frame in the fileSequence
    if (~isempty(fileSequence(i_File).first_frame) & ~isempty(fileSequence(i_File).last_frame)   )
        FileInfo(i_File).NFrames = fileSequence(i_File).last_frame - fileSequence(i_File).first_frame + 1;
        FileInfo(i_File).UDP_StimFrames = frameSynch(2,FileInfo(i_File).first_frame:FileInfo(i_File).last_frame);
%             FileInfo(i_File).UDP_TimeArrivalMSec = frameArrivalTime(FileInfo(i_File).first_frame:FileInfo(i_File).last_frame);    % Not too useful
    end
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Get info sent over from BhvCtrl. 
    
    % NOTE: Need to correct for bhv 'trials' that don't register in the image, e.g when rattling lever.
    % So get REGISTERED trial # from frameSynch, not from BhvCtrl trials
    % Then get a mismatch between BhvCtrl & frameSynch trial numbers
    FileInfo(i_File).GlobalTrialNum = frameSynch(4,FileInfo(i_File).first_frame);
    FileTrialMismatch = FileInfo(i_File).GlobalTrialNum - trials(i_File).head.TrialNumber;
    i_Trial = i_File + FileTrialMismatch;
    
    FileInfo(i_File).TrialIndex = i_Trial;     % Sequential position of given file / trial
   
    % Stim identity: NOTE: for Stim movie, covering for earlier case where the path wasn't recorded
    % NOTE: also, assume that the first field in trials().stim is the stimulus type
   
    names = fieldnames(trials(i_Trial).stim);
    stimInd = strmatch(names{1}, StimTypes);
    
    
    if ~isempty(stimInd)
        switch stimInd
        case    strmatch('STIMULUS_GRATING', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_GRATING';   StimTypeFlg = 0;
            FileInfo(i_File).GratingOrientation = trials(i_Trial).stim.STIMULUS_GRATING.GratingOrientation;
        case    strmatch('STIMULUS_ANNULAR', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_ANNULAR'; StimTypeFlg = 0;
        case strmatch('STIMULUS_PAIR', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_PAIR'; StimTypeFlg = 0;
        case strmatch('STIMULUS_TRIPLET', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_TRIPLET'; StimTypeFlg = 0;
        case    strmatch('STIMULUS_IMAGE', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_IMAGE';   StimTypeFlg = 1;
            FileInfo(i_File).BitmapStim = trials(i_Trial).stim.STIMULUS_IMAGE.Path;  
        case    strmatch('STIMULUS_MOVIE', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_MOVIE';   StimTypeFlg = 1;
            FileInfo(i_File).BitmapStim = trials(i_Trial).stim.STIMULUS_MOVIE.Path;  
            if isempty(FileInfo(i_File).BitmapStim)     FileInfo(i_File).BitmapStim = trials(i_Trial).stim.STIMULUS_MOVIE.Name;  end
        case    strmatch('STIMULUS_BLANK', StimTypes)
            FileInfo(i_File).StimType = 'STIMULUS_BLANK';   
            FileInfo(i_File).BitmapStim = 'blank_trial';
            FileInfo(i_File).GratingOrientation = 'blank_trial';
        otherwise
            disp('StimType not properly listed?');
        end
    else
        error([mfilename ': Unknown stimulus type ' names{1}]);
    end
        
    % FileInfo(i_File).GratingOrientation = str2num(Trls(Indx).stim.STIMULUS_GRATING.GratingOrientation);
    FileInfo(i_File).Outcome = trials(i_Trial).head.Outcome;  

    FileInfo(i_File).StartTimeActual = trials(i_Trial).head.StartTime;
    FileInfo(i_File).EndTimeActual = trials(i_Trial).head.EndTime;
    if (FileInfo(i_File).EndTimeActual <= FileInfo(i_File).StartTimeActual) 
        fprintf('Trial %d: Error in start / end times. Excise this & all later trials from FileInfo ?\n', i_File);
        FileInfoErrorFlg = 1;
    end
        
    if(i_File == 1)     Time0 = FileInfo(1).StartTimeActual;    HEADER.Time0 = Time0;       end
    
    % Sep 16 2006: refer start times to the time of the first trial.
    FileInfo(i_File).StartTime = trials(i_Trial).head.StartTime - Time0;
    FileInfo(i_File).EndTime = trials(i_Trial).head.EndTime - Time0;
    
    % NOTE: Need to get number of events by counting # of events in trial.events since TotalEvents misses a number of events.
    if  ~isempty(trials(i_Trial).events)  % When no events registered then trial.events = []
        x = {trials(i_Trial).events(:).Event};
        FileInfo(i_File).NEvents = length(x);
        x = cell2mat(x');   FileInfo(i_File).MsgEvents = x;   % Array of all events
        t = [trials(i_Trial).events(:).Time] - Time0 - StartTimeGlue(i_File);   FileInfo(i_File).MsgTimes = t' ;   % Array of event times REF TO absolute start;
        
        index = strmatch('MsgFixationPeriod',x);   % NOTE: message in pairs: start & stop.
        if index    FileInfo(i_File).TFixPeriodOn = t(index(1));     end 
        if size(index,1) == 2      FileInfo(i_File).TStimOff = t(index(2));      end   
        
        index = strmatch('MsgStimulusShow',x); 
        if index  FileInfo(i_File).TStimOn = t(min(index)); end     % Dec 15 2006: NOTE: min(index) because of paired MsgStimulusShow 
        
        index = strmatch('MsgStimulusShift',x); 
        if index  FileInfo(i_File).TStimShift = t(index); end
        
        index = strmatch('MsgStartReward', x);  % NOTE: message in pairs: start & stop.
        if index    FileInfo(i_File).TStartReward = t(index(1)); end
    else
        FileInfo(i_File).NEvents = 0;
    end
    
end

if (FileInfoErrorFlg)   disp('Excise any trials ? E.g., set FileInfo(m:n) = []. REDUCE NumTrials by same amount; Return to continue'); keyboard; end
HEADER.NumTrials = NumTrials;

HEADER.FramePer = FramePer;
HEADER.FrameFreq = 1000 / HEADER.FramePer;

% Get the set of unique stimulus names
UniqueStimTypes = unique({FileInfo(:).StimType});

switch  StimTypeFlg
case    0
    UniqueStimuli=unique({FileInfo(:).GratingOrientation});
case    1
    UniqueStimuli=unique({FileInfo(:).BitmapStim});
otherwise   
    disp('Unrecognized stim');
end
fprintf('\n%d Stim Types present:\n', length(UniqueStimTypes)); for i=1:length(UniqueStimTypes)   fprintf('%s\n', UniqueStimTypes{i});    end
fprintf('\n%d unique stimuli:\n', length(UniqueStimuli));   for i=1:length(UniqueStimuli)   fprintf('%s\n', UniqueStimuli{i}); end

% Get the set of unique UDP synch values
UniqueUDP_Stim = unique(horzcat(FileInfo(:).UDP_StimFrames));

HEADER.StimTypes = UniqueStimTypes;
HEADER.UniqueStimuli = UniqueStimuli;
HEADER.UniqueUDP_Stim = UniqueUDP_Stim;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Start filling time_trace
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('Extracting eye trial info');
[eye_header,eye_trials] = readEyeFile(eyeFile, 'Val_MatFormat', Val_MatFormat);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Here, at the end of the most time consuming step.
disp('Saving temp1.mat at end of read eye trial info');
save temp1.mat;
% clear all
% load temp1.mat;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Extract eye x, y, pupil R & t, and outcome; Fill time_trace
temp = [eye_trials.data];

% T: total number of TIME points %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
T = 0;
for n = 1:length(temp)
    T = T + length(temp(n).points);
end
clear temp;

% T = length([temp.points]); clear temp;      
time_trace = zeros(length(time_labels),T);
if (length(eye_trials) ~= NumTrials)    
    fprintf('WARNING: Num of eye trials: %d;  does not match num of trials from bhv file: %d\n', length(eye_trials), NumTrials); 
end

ind = 1;
for n = 1:length(eye_trials)
    temp = [eye_trials(n).data];
    temp = [temp.points];
    if ~isempty(temp)
        inds = (ind):(ind-1+length([temp.X]));
        time_trace(strmatch('eye_x', time_labels),inds) = [temp.X];
        time_trace(strmatch('eye_y', time_labels),inds) = [temp.Y];
        if (Val_MatFormat ~= 2); time_trace(strmatch('eye_r', time_labels),inds) = [temp.R]; end;    % Pupil data
        if (Val_MatFormat >= 4); time_trace(strmatch('breath', time_labels),inds) = [temp.B]; end;
        time_trace(strmatch('eye_t', time_labels),inds) = [temp.T];
        time_trace(strmatch('trial', time_labels),inds) = eye_trials(n).head.TrialNumber;
        time_trace(strmatch('outcome', time_labels), inds) = trials(n).head.Outcome;
        ind = ind + length([temp.X]);
    end
end
% keyboard;
% Set of trial numbers recorded in FileInfo
CorrectTrialNums = [FileInfo(:).GlobalTrialNum];


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('Saving temp2.mat after filling in time_trace');
save temp2.mat;
% clear all
% load temp2.mat;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Set start time = Time0; 
time_trace(strmatch('eye_t', time_labels),:) = time_trace(strmatch('eye_t', time_labels),:) - Time0;

% Mean period between eye trace samples
TimePer = mean(diff(time_trace(strmatch('eye_t', time_labels),1:end)));   
HEADER.TimePer = TimePer;
HEADER.TimeSampleFreq = 1000 / TimePer;
HEADER.Frame_TimeRatio = FramePer / TimePer;
fprintf('Mean frame period (ms): %f \t\t(Freq: %f Hz)\nMean eye_t sample period: %f \t(Freq: %f Hz)\nRatio: FramePer / TimePer: %f\n', ...
    FramePer, 1000/FramePer, TimePer, 1000/TimePer, FramePer/TimePer);

clear eye_trials temp;  % Freeing up memory

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('Saving temp4 after glueing together time trace');
save temp4.mat;
% clear all
% load temp4.mat;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Timing info in FRAME units
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% L: Total number of FRAMES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% set up for filtering out heartbeat
params.Fs = HEADER.FrameFreq;
params.f0 = 0.5;      % Default: for low pass filtering 0 -> 1.0 Hz; set f0 = centre with width W = the same
params.W = 0.5;

L = length(frameSynch);     
frame_trace = zeros(length(frame_labels), L);
frame_trace(strmatch('trial', frame_labels), :) = frameSynch(4,:);
frame_trace(strmatch('stim', frame_labels), :) = frameSynch(2,:);

% NOTE: cropping to L since the frameMeans may be of diff lengths
for i=1:nWvLngths
    load([synchPath synchFileAry(i).name], 'frameMean');
    frame_trace(strmatch(['mean' synchFlLbl{i}],frame_labels,'exact'),:) = frameMean(1:L);
    frame_trace(strmatch(['mean' synchFlLbl{i} '_Fltr'],frame_labels,'exact'),:) = transpose(SerialFilter(frameMean(1:L), params));
end

% Get HR: from green, if available (better pulse signal?)
if nWvLngths >= 2
    pulse = diff(frame_trace([strmatch(['mean' synchFlLbl{2}],frame_labels,'exact'), ...
        strmatch(['mean' synchFlLbl{2} '_Fltr'],frame_labels,'exact')],:));
else
    pulse = diff(frame_trace([strmatch(['mean' synchFlLbl{1}],frame_labels,'exact'), ...
        strmatch(['mean' synchFlLbl{1} '_Fltr'],frame_labels,'exact')],:));
end
HR = getInstantaneousHeartRate(pulse, HEADER.FrameFreq);
frame_trace(strmatch('HR',frame_labels,'exact'),:) = HR;
frame_trace(strmatch('HR_Fltr',frame_labels),:) = runline(HR,round(1000/FramePer),1);

for i=1:NumTrials
    inds = find(frame_trace(strmatch('trial',frame_labels), :) == FileInfo(i).GlobalTrialNum);
    frame_trace(strmatch('outcome', frame_labels), inds) = FileInfo(i).Outcome;
end

% Store partially completed info (because of occasional 'out of memory'
fileOut = [dirFileInfo header.ExperimentName '_FileInfo.mat'];
save(fileOut, 'FileInfo', 'time_trace', 'frame_trace', 'HEADER');
fprintf('Partial info written info file %s\n', fileOut);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('Saving temp5 after calculating image means');
save temp5.mat;
% clear all
% load temp5.mat;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Aligning FRAME with TIME (linking the TRIAL TRANSITION in frames with the start time of each trial)
% NOTE: Time_Frame_Mismatch calculates the amount by which the Msg time is larger than the MIDPOINT of the frame
%   where the corresponding message got registered. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% IMP: 1: NOTE the extra 1 in the array because 1: diff does not show the first frame & 2: diff jumps the index back by 1;
TrialTransitionsFRAME = find([1 diff(frame_trace(strmatch('trial',frame_labels),:) )   ]  );      
TrialTransitionsTIME = [FileInfo(:).StartTime]  / FramePer;
LOverlap = min(size(TrialTransitionsTIME,2), size(TrialTransitionsFRAME, 2));
Time_Frame_Mismatch = 0.5 + mean(TrialTransitionsTIME(2:LOverlap) - TrialTransitionsFRAME(2:LOverlap));   % Ignore first point: trial start uncertain
% NOTE: time E.G = 174.5 should fall on mindpoint of frame 175; thus TIME-FRAME mismatch > 0 means time EXCEEDS midpoint of frame in which it should fall
%   i.e. frame counting started LATER and needs to be caught up with time counting
fprintf('\nOverall Time-Frame mismatch:\nMessage time exceeds corresponding Frame MIDPOINT by %f frames\n', Time_Frame_Mismatch);
HEADER.Time_Frame_Mismatch = Time_Frame_Mismatch;

% Enter aligned frame DURATIONS on time_trace. NOTE: Aligned on frame MIDPOINT. Positive mismatch -> frames need to catch up
disp('Aligning frames to time');
FrameTimesAligned = ([0:L-1] + 0.5 + Time_Frame_Mismatch)*FramePer;

% Instead of laboriously assigning each frame point to the closest corresponding time, just multiply by proportionality constant; Fill in the ends
% NOTE: The first time stamp in the eye trace is NOT time=zero. Need to offset by this amount when aligning on 
% First calculate the T_Intercept = <Y> - m<X>,  m = TimePer, X = set of numbers 1:T, Y: set of eye_t
T_Intercept = mean(time_trace(strmatch('eye_t', time_labels),:)) - TimePer * mean([1:T]) + TimePer; % NOTE extra TimePer: need intercept at X=1
HEADER.T_Intercept = T_Intercept;
inds = round((FrameTimesAligned -T_Intercept)/ TimePer)+1;
for i=1:L-1
    if ((inds(i) >= 1) & (inds(i) < T) & ((inds(i+1) - 1) < T))  time_trace(strmatch('frame', time_labels), inds(i):inds(i+1)-1) = i; end
end
% If FrameTimesAligned extends below inds = 1, fill the first set with the highest frame number inds < 1; Similarly, if beyond T, will with lowest beyond that lim
indsLo = max(find(inds < 1));   if ~isempty(indsLo)    time_trace(strmatch('frame', time_labels),1:inds(indsLo+1)-1) = indsLo;   end
indsHi = min(find(inds > T+1)); 
if ~isempty(indsHi)     time_trace(strmatch('frame', time_labels),inds(indsHi-1):T) = indsHi-1;
else    time_trace(strmatch('frame', time_labels),inds(L):T) = L;    end

% Enter frame time stamps in frame_trace. Convert to TBin
frame_trace(strmatch('time', frame_labels), :) = FrameTimesAligned;
frame_trace(strmatch('tBin', frame_labels), :) = round((FrameTimesAligned - T_Intercept)/TimePer)+1;


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Align message events on sample times and on frame times (after correction for time_frame mismatch)
% On time_event_trace: put frame stamp in relevant position
% On frame_event_trace: put time_trace index / time stamp.
% Aug 22 2006: 2 more rows: marking duration of StimShow & ShifShift
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% First identify unique events.
disp('Position events on time trace');
% Get all MsgEvents & MsgTimes. Extract unique set of events
MsgEvents = vertcat(FileInfo(:).MsgEvents);
MsgTimes = vertcat(FileInfo(:).MsgTimes);
UniqueEvents = unique(MsgEvents, 'rows'); 
% Add DurStimON & DurStimSHIFT as last 2 rows
NEvents= size(UniqueEvents,1);
UniqueEvents(NEvents+1:NEvents+2,:) = zeros(2,size(UniqueEvents,2));
UniqueEvents(NEvents+1,1:length('DurStimON')) = 'DurStimON';
UniqueEvents(NEvents+2,1:length('DurStimSHIFT')) = 'DurStimSHIFT';
NEvents = size(UniqueEvents,1); % Include the DurStimON & DurStimSHIFT
for i=1:NEvents  event_labels{i} = (removetrailzeros(UniqueEvents(i,:))); end
HEADER.event_labels = event_labels;
fprintf('%d unique msg events\n', NEvents); UniqueEvents

% Again, save partial info. 
% Dec 9 2006: changed to floor for frame bin, not round; logic: frame where the event was registered (anywhere witihn frame). 
% Time bin: by contrast, time markers closest to a time point, not intervals
HEADER.Time_TimeBinConversion = 'TimeBin = round((Time -T_Intercept)/ TimePer)+1;';
HEADER.Time_FrameBinConversion = 'FrameBin = floor((Time/ FramePer)- Time_Frame_Mismatch) + 1;'

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Save temporary file outs 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

save(fileOut, 'FileInfo', 'time_trace', 'frame_trace', 'HEADER')

% % clear time_trace;   % Free up memory

% Next fill trace positions with row index from the match with unique event
% Instead of minimizing the absolute time diff to match each time, simply divided by proportionality constant. 
% Checked: the two give IDENTICAL results for the messages tested, Aug 2 2006
% Note, again: shift by T_Intercept
% Aug 22 2006: Add 2 rows to accomodate DurStimON & DurStimSHIFT. Make default = -1 & not 0 to allow stim = 0

evtPos = [];

time_event_trace = zeros(NEvents, T);  time_event_trace(NEvents-1:NEvents, :) = -1;
frame_event_trace = zeros(NEvents, L); frame_event_trace(NEvents-1:NEvents, :) = -1;

MsgFrames = floor((MsgTimes/ FramePer)- Time_Frame_Mismatch) + 1;    % Note +1 to count frames from 1; Dec 9 '06: Note: floor, not round
indsT = round((MsgTimes - T_Intercept)/ TimePer) + 1;
for i=1:length(MsgFrames)    
    evtPos(i) = strmatch(removetrailzeros(MsgEvents(i,:)),event_labels);
    if ((indsT(i) >= 1) & (indsT(i) <= T) & (MsgFrames(i) >= 1) & (MsgFrames(i) <= L))    
        time_event_trace(evtPos(i), indsT(i)) = MsgFrames(i);
        frame_event_trace(evtPos(i), MsgFrames(i)) = indsT(i);
    end
end

% Identify all the evtPos corresponding to MsgStimulusShow, MsgStimulusShift
% Then identify the corresponding UDP synch 2 value (frame_label 'stim'). Idea: look for a step change in the stim value.
%   Due to possible frame mismatch look for a transition within +/- 2 frames (+/- 1 not enough with frame jitter). 
%   If no stim transition found, issue warning.
% First, for MsgStimShow, then for MsgStimShift
% Finally, for each MsgStimShow & MsgStimShift fill the frame & time trace indices from the Msg to the next Msg with the last UDP synch value
if ~isempty(evtPos)
    StimShowPos = find((evtPos == strmatch('MsgStimulusShow', event_labels)));
    if ~isempty(strmatch('MsgStimulusShift', event_labels))
        StimShiftPos = find((evtPos == strmatch('MsgStimulusShift', event_labels)));
    else
        StimShiftPos = find((evtPos == strmatch('MsgFixationPeriod', event_labels)));
    end
else
    StimShowPos = [];
    StimShiftPos = [];
    StimONTrans = [];
    StimSHIFTTrans = [];
end

% YBS: somehow MsgFrames has message indices that are beyond the length of
% frame_trace by as much as 119 frames (this is actually an entire trial)

for i=1:length(StimShowPos)
    ind = MsgFrames(StimShowPos(i));
    
    keyboard
    StimONTrans(i,1:5) = frame_trace(strmatch('stim', frame_labels), ind-2:ind+2);
end
difTrans = diff(StimONTrans, 1, 2); difTrans = sum(difTrans, 2); difTrans = find(difTrans == 0);    % See if UDP synch changes over +/- 2 frames
for i=1:length(difTrans)  TrialNum = frame_trace(strmatch('trial', frame_labels),MsgFrames(StimShowPos(difTrans(i))));
    fprintf('Warning: UDP synch %d: MsgStimShow: No change at frame %d (Trial %d; Trial index %d; Outcome: %d)\n', StimONTrans(difTrans(i)), ...
        MsgFrames(StimShowPos(difTrans(i))), TrialNum, find(CorrectTrialNums == TrialNum), FileInfo(find(CorrectTrialNums == TrialNum)).Outcome);
end
for i=1:length(StimShiftPos) ind = MsgFrames(StimShiftPos(i)); StimSHIFTTrans(i,1:5) = frame_trace(strmatch('stim', frame_labels), ind-2:ind+2);    end
difTrans = diff(StimSHIFTTrans, 1, 2); difTrans = sum(difTrans, 2); difTrans = find(difTrans == 0);
for i=1:length(difTrans)  TrialNum = frame_trace(strmatch('trial', frame_labels),MsgFrames(StimShiftPos(difTrans(i))));
    fprintf('Warning: UDP synch %d: MsgStimShift: No change at frame %d (Trial %d; Trial index %d; Outcome: %d)\n', StimSHIFTTrans(difTrans(i)), ...
        MsgFrames(StimShiftPos(difTrans(i))), TrialNum, find(CorrectTrialNums == TrialNum), FileInfo(find(CorrectTrialNums == TrialNum)).Outcome);
end
% for i=1:length(StimShowPos) 
%     if((indsT(StimShowPos(i)) >= 1) & (indsT(StimShowPos(i)+1) < T) & (MsgFrames(StimShowPos(i)) >= 1) & (MsgFrames(StimShowPos(i)+1) < L))
%         frame_event_trace(strmatch('DurStimON', event_labels), MsgFrames(StimShowPos(i)):MsgFrames(StimShowPos(i)+1)-1) = StimONTrans(i,5);
%         time_event_trace(strmatch('DurStimON', event_labels), indsT(StimShowPos(i)):indsT(StimShowPos(i)+1)-1) = StimONTrans(i,5);
%     end
% end
for i=1:length(StimShiftPos) 
    if((indsT(StimShiftPos(i)) >= 1) & (indsT(StimShiftPos(i)+1) < T) & (MsgFrames(StimShiftPos(i)) >= 1) & (MsgFrames(StimShiftPos(i)+1) < L))
        frame_event_trace(strmatch('DurStimSHIFT', event_labels), MsgFrames(StimShiftPos(i)):MsgFrames(StimShiftPos(i)+1)-1) = StimSHIFTTrans(i,5);
        time_event_trace(strmatch('DurStimSHIFT', event_labels), indsT(StimShiftPos(i)):indsT(StimShiftPos(i)+1)-1) = StimSHIFTTrans(i,5);
    end
end

% Filling the empty fields in FileInfo with time info in frame units and TBin units:
for i=1:NumTrials
    FileInfo(i).MsgFrames = floor(FileInfo(i).MsgTimes/FramePer - Time_Frame_Mismatch) + 1;
    FileInfo(i).MsgTimeBin = round((FileInfo(i).MsgTimes - T_Intercept)/TimePer) + 1;
    FileInfo(i).FrameFixPeriodOn = floor(FileInfo(i).TFixPeriodOn/FramePer - Time_Frame_Mismatch) + 1;
    FileInfo(i).FrameFixPeriodOnRel = FileInfo(i).FrameFixPeriodOn - FileInfo(i).first_frame + 1;
    FileInfo(i).FrameStimOn = floor(FileInfo(i).TStimOn/FramePer - Time_Frame_Mismatch) + 1;
    FileInfo(i).FrameStimOnRel = FileInfo(i).FrameStimOn - FileInfo(i).first_frame + 1;
    FileInfo(i).FrameStimShift = floor(FileInfo(i).TStimShift/FramePer - Time_Frame_Mismatch) + 1;
    FileInfo(i).FrameStimShiftRel = FileInfo(i).FrameStimShift - FileInfo(i).first_frame + 1;
    FileInfo(i).FrameStimOff = floor(FileInfo(i).TStimOff/FramePer - Time_Frame_Mismatch) + 1;
    FileInfo(i).FrameStimOffRel = FileInfo(i).FrameStimOff - FileInfo(i).first_frame + 1;
    
    FileInfo(i).TBin_StartTime = round((FileInfo(i).StartTime -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_EndTime = round((FileInfo(i).EndTime -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_FixOn = round((FileInfo(i).TFixPeriodOn -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_StimOn = round((FileInfo(i).TStimOn -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_StimShift = round((FileInfo(i).TStimShift -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_StimOff = round((FileInfo(i).TStimOff -T_Intercept)/ TimePer)+1;
    FileInfo(i).TBin_StartReward = round((FileInfo(i).TStartReward -T_Intercept)/ TimePer)+1;
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Excise any excess bins in frame_trace and frame_event_trace
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(size(frame_trace,2) > FileInfo(end).last_frame)
    frame_trace(:,FileInfo(end).last_frame+1:end) = [];
    frame_event_trace(:,FileInfo(end).last_frame+1:end) = [];
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Save in files BEFORE plexon data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

save(fileOut, 'FileInfo', 'time_trace','time_event_trace', 'frame_trace', 'frame_event_trace');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('Saving temp6 after aligning frames');
save temp6.mat;
% clear all
% load temp6.mat;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% AD: (Mar 12 '08): Moved to the end so that even with mismatches of Plx
% events, can manually comment out relevant lines & save the rest.
%%%% PLEXON DATA %%%%
if strcmpi('yes', hasPlx)
    
    defs = getPLXdefs; % load default PLX definitions

    % get all units binned at TimePer
    [spikeTrc,spikeT] = getSingleUnitTrace(plxHeader,plxData,1,[],TimePer/1000);
    spikeT = spikeT*1000; % convert from seconds to milliseconds

    % ignore spikeTrc because it must be recomputed after alignining the
    % time-bases of plexon and bhvCtrl
    % Strategy: to align (stretch & shift) Plx time base to Bhv: use Trial Onsets

    plxTrialEnds = getEvents(plxHeader,plxData,defs.PL_ExtEventType,4)*1000;
    plxNumTrials = length(plxTrialEnds);
    
    % if the number of trial onsets matches -- we're cool
    if plxNumTrials==NumTrials
        % take trials 2:end to synchronize
        bhvTrialEndsTemp = [FileInfo(2:end).EndTime];
        plxTrialEndsTemp = plxTrialEnds(2:NumTrials);
        %     plxTrialEndsTemp = plxTrialEnds(1:NumTrials-1);
    else
        fprintf('%s: Number of trial Ends in PLX (%i) does not match that in BHV (%i)\n',mfilename,plxNumTrials,NumTrials);
        % attempt to align the data sets using ITI
        plxITI = diff(plxTrialEnds);
        bhvITI = diff([FileInfo(:).StartTime]);
        
        % assume that only trials from the end or the beginning are missing
        % slide the plexon ITIs across bhvITIs to find best match
        slideN = abs(NumTrials-plxNumTrials);
        slidePos = -slideN:slideN;
        match = zeros(1,length(slidePos));
        for n = 1:length(slidePos)
            tmpMax = min([NumTrials,plxNumTrials])-abs(slidePos(n))-1;
            if slidePos(n)<0
                match(n) = sqrt(mean((plxITI(1:tmpMax)-bhvITI((1:tmpMax)-slidePos(n))).^2));
            else
                match(n) = sqrt(mean((plxITI((1:tmpMax)+slidePos(n))-bhvITI(1:tmpMax)).^2));
            end
        end
        [minMatch,minPos] = min(match);
        plxToBhvFrameshift = slidePos(minPos);
        fprintf('%s: Best match between PLX and BHV ITIs is %1.2f msecs (frameshift of %i trials)\n',mfilename,minMatch,slidePos(minPos));
        tmpMax = min([NumTrials,plxNumTrials])-abs(plxToBhvFrameshift);
        if plxToBhvFrameshift<0
            bhvTrialEndsTemp = [FileInfo((2:tmpMax)-plxToBhvFrameshift).StartTime];
            plxTrialEndsTemp = plxTrialEnds(2:tmpMax);
        else
            plxTrialEndsTemp = plxTrialEnds((2:tmpMax)+plxToBhvFrameshift);
            bhvTrialEndsTemp = [FileInfo(2:tmpMax).StartTime];
        end
    end

    % find the difference between the Trial Onset time-stamps
    time_diff = plxTrialEndsTemp-bhvTrialEndsTemp;

    % Calculate linear transformation betw bhv & plx trial onsets
    % remove linear trends from time_diff to better isolate ouliers relative to
    % any stable mean
    r = regress(time_diff',[(1:length(time_diff))' ones(length(time_diff),1)]);
    time_diff_outlier = time_diff - (1:length(time_diff))*r(1)-r(2);

    m_time_diff_outlier = mean(time_diff_outlier);
    std_time_diff_outlier = std(time_diff_outlier);

    % reject trials having a time difference of > 6 std units
    align_thresh = 6;
    good_diff = time_diff_outlier>(m_time_diff_outlier-std_time_diff_outlier*align_thresh) & time_diff_outlier<(m_time_diff_outlier+std_time_diff_outlier*align_thresh);

    % this is the ORIGINAL time_diff excluding the outliers from
    % time_diff_outlier
    time_diff_clean = time_diff(good_diff);

    % recompute the regression
    r = regress(time_diff_clean',[bhvTrialEndsTemp(good_diff)' ones(length(time_diff_clean),1)]);

    % r(1) is slope and r(2) is offset plx=r(1)*bhv+r(2)
    HEADER.PLX_SlopeAndOffset = r;
    fprintf('%s: Plexon relative time drift slope = %1.4f (offset = %1.2f)\n',mfilename,r(1),r(2));
    spikeT_corr = spikeT-r(2)-spikeT*r(1);
    
    % get plexon event timestamps & correct to Bhv time base
    plxTrialOnsets = getEvents(plxHeader,plxData,defs.PL_ExtEventType,3)*1000;
    plxTrialEnds = getEvents(plxHeader,plxData,defs.PL_ExtEventType,4)*1000;
    plxStimOnsets = getEvents(plxHeader,plxData,defs.PL_ExtEventType,7)*1000;
    plxStimShift = getEvents(plxHeader,plxData,defs.PL_ExtEventType,8)*1000;
    plxStimOff = getEvents(plxHeader,plxData,defs.PL_ExtEventType,9)*1000;
    
    plxTrialOnsets_corr = plxTrialOnsets-r(2)-plxTrialOnsets*r(1);
    plxTrialEnds_corr = plxTrialEnds-r(2)-plxTrialEnds*r(1);
    plxStimOnsets_corr = plxStimOnsets-r(2)-plxStimOnsets*r(1);
    plxStimShift_corr = plxStimShift-r(2)-plxStimShift*r(1);
    plxStimOff_corr = plxStimOff-r(2)-plxStimOff*r(1);

    % put plexon stim onset triggers into FileInfo (they are more reliable)
    % NOTE: for Stim times, only for correct trials 
    
    % for each event, find the closest matching bhvTrial to match it to
    timeDiffOnsets = zeros(size(plxTrialOnsets_corr));
    bhvTrialsOnsets = [FileInfo(:).StartTime];
    for n = 1:length(plxTrialOnsets_corr)
        [timeDiffOnsets(n),bhvInd] = min(abs(bhvTrialsOnsets-plxTrialOnsets_corr(n)));
        FileInfo(bhvInd).Plx_StartTime = plxTrialOnsets_corr(n);
    end

    timeDiffEnds = zeros(size(plxTrialEnds_corr));
    bhvTrialsEnds = [FileInfo(:).EndTime];
    for n = 1:length(plxTrialEnds_corr)
        [timeDiffEnds(n),bhvInd] = min(abs(bhvTrialsEnds-plxTrialEnds_corr(n)));
        FileInfo(bhvInd).Plx_EndTime = plxTrialEnds_corr(n);
    end
    
    timeDiffStimOn = zeros(size(plxStimOnsets_corr));
    bhvStimOnsets = [FileInfo(:).TStimOn];
    for n = 1:length(plxStimOnsets_corr)
        [timeDiffStimOn(n),bhvInd] = min(abs(bhvStimOnsets-plxStimOnsets_corr(n)));
        FileInfo(bhvInd).Plx_TStimOn = plxStimOnsets_corr(n);
    end
    
    timeDiffStimShift = zeros(size(plxStimShift_corr));
    bhvStimShift = [FileInfo(:).TStimOn];
    for n = 1:length(plxStimShift_corr)
        [timeDiffStimShift(n),bhvInd] = min(abs(bhvStimShift-plxStimShift_corr(n)));
        FileInfo(bhvInd).Plx_TStimShift = plxStimShift_corr(n);
    end
    
    timeDiffStimOff = zeros(size(plxStimOff_corr));
    bhvStimOff = [FileInfo(:).TStimOn];
    for n = 1:length(plxStimOff_corr)
        [timeDiffStimOff(n),bhvInd] = min(abs(bhvStimOff-plxStimOff_corr(n)));
        FileInfo(bhvInd).Plx_TStimOff = plxStimOff_corr(n);
    end
    
%     cStim = 1; cShift = 1; cOff = 1;
%     for n = 1:length(FileInfo)
%         FileInfo(n).Plx_StartTime = plxTrialOnsets_corr(n);
%         FileInfo(n).Plx_EndTime = plxTrialEnds_corr(n);
%         if ~isempty(plxStimOnsets)
%             if ~isnan(FileInfo(n).TStimOn)
%                 FileInfo(n).Plx_TStimOn = plxStimOnsets_corr(cStim);
%                 cStim = cStim + 1;
%             else
%                 FileInfo(n).Plx_TStimOn = NaN;
%             end
%         end
%         if ~isempty(plxStimShift)
%             if ~isnan(FileInfo(n).TStimShift)
%                 FileInfo(n).Plx_TStimShift = plxStimShift_corr(cShift);
%                 cShift = cShift + 1;
%             else
%                 FileInfo(n).Plx_TStimShift = NaN;
%             end
%         end
%         if ~isempty(plxStimOff)
%             if ~isnan(FileInfo(n).TStimOff)
%                 FileInfo(n).Plx_TStimOff = plxStimOff_corr(cOff);
%                 cOff = cOff + 1;
%             else
%                 FileInfo(n).Plx_TStimShift = NaN;
%             end
%         end
%     end
    
    % crop spikeT to the duration of the bhvCtrl data
    spikeT_corr = spikeT_corr(spikeT_corr<=time_trace(strmatch('eye_t',time_labels),end));
    % remove spikes before alignment
    spikeT_corr = spikeT_corr(spikeT_corr>0);
    
    % AD: Mar 10 08: scaling spikeTrace to spikes / sec from spikes / bin
    spikeTrace = binSpikes(spikeT_corr,TimePer,size(time_trace,2)) .* (1000 / TimePer);
    time_trace(strmatch('spikeT',time_labels,'exact'),:) = spikeTrace;
    % add in a filtered spike trace (runline of 1sec duration)
%     time_trace(strmatch('spikeT_Fltr',time_labels),:) = runline(spikeTrace,round(1000/TimePer),1);
    time_trace(strmatch('spikeT_Fltr',time_labels),:) = runline(spikeTrace,round(500/TimePer),1);

    % fill frame_trace with spikes binned at FramePer. AD: Mar 10 08: scale to spikes / sec
    spikeT_frame = spikeT_corr-Time_Frame_Mismatch*FramePer;
    spikeT_frame = spikeT_frame(spikeT_frame>0);
    spikeTrace = binSpikes(spikeT_frame,FramePer,size(frame_trace,2)) .* (1000 / FramePer);
    frame_trace(strmatch('spikeF',frame_labels,'exact'),:) = spikeTrace;
    % add in a filtered spike trace (runline of 1sec duration)
%     frame_trace(strmatch('spikeF_Fltr',frame_labels),:) = runline(spikeTrace,round(1000/FramePer),1);
    frame_trace(strmatch('spikeF_Fltr',frame_labels),:) = runline(spikeTrace,round(500/FramePer),1);
end

save(fileOut, 'FileInfo', 'time_trace', 'time_event_trace','frame_trace', 'frame_event_trace', 'HEADER')
if strcmpi('yes', hasPlx);   save(fileOut,'plxData','plxHeader', '-append'); end
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fprintf('Written final info file %s\n', fileOut);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bind Bhv to Img (if BindToFile == 1)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if (BindToFile == 1)
    disp('Binding trial info to files');
    if ~existsFlnmFormat    flnmFormat = ['%s' header.ExperimentName '_0*_%05i.mat']; end
	for n = 1:NumTrials
        fileName = sprintf(flnmFormat ,dirImgFiles, trials(n).head.TrialNumber); 
        d = dir(fileName);
        if ((length(d) == 1) & ~ d.isdir)
            fprintf('%s: adding bhv info to file %s\n',mfilename,d.name);
            bindDataToMatMovie(header,trials(n),'root',[root dest_path],'fileName',fileName,'eye_trial',eye_trials(n));
        else
            warning([mfilename ': skipping file ' fileName ' because it does not exist']);
        end
	end
end

diary off;

%%%%%%%SUPPORTING FUNCTIONS%%%%%%%%%%%%%%%%%%%
function trace = binSpikes(timeStamps,binSize,trcSize)

trace = zeros(1,trcSize);

% bin the spikes at the eye sampling rate
spikeT_wnd = round(timeStamps/binSize)+1;
spikeT_wnd_u = unique(spikeT_wnd);

for n = 1:length(spikeT_wnd_u)
    trace(spikeT_wnd_u(n)) = sum(spikeT_wnd==spikeT_wnd_u(n));
end

trace = trace(1:trcSize);

%%%%%%%%% Reading SYNCH files in sequence, trimming to shortest, returning
%%%%%%%%% fileSequence, frameSynch, frameArrivalTime, number of wavelengths, etc
function [synchFileAry fileSequence frameSynch frameArrivalTime nWvLngths synchFlLbl FlnmAry] = getSynchFileInfo(synchPath, synchFile)


% Look for multiple synch files named e.g. STR2_1_00104_00104_SYNCH.mat, STR2_2_00104_00104_SYNCH.mat
ind_ = min(findstr('_', synchFile));
synchFileTmplt = synchFile; synchFileTmplt(ind_+1) = '*';
synchFileAry = dir([synchPath synchFileTmplt]);
nWvLngths = size(synchFileAry,1);

% List synch files as well as their individual identifying labels (as a cell array)
fprintf('Synch files: \n');   
for i=1:nWvLngths;    synchFlLbl{i} = synchFileAry(i).name(ind_ + 1);   end;

% Open all the file sequentially to get set of all fileSequence. Set first one to Master fileSequence & match others to it.
% Start from last one & work backwards, to set the first (red) as master
% Get list of file names from each fileSequence for later insertion into FileInfo, as a cell array of cells
for i=0:nWvLngths-1
    load([synchPath synchFileAry(nWvLngths-i).name], 'fileSequence');
    FlnmAry{nWvLngths-i} = {fileSequence(:).name};
    if ~isempty((fileSequence(end).last_frame))  nFramesTotalTemp = fileSequence(end).last_frame; 
    else    fprintf('fileSequence(end).last_frame is empty;')
        fprintf('Check fileSequence for last non-empty last_frame; Set nFramesTotalTemp = this value. Then hit "return"'); keyboard
    end
    fprintf('%s: %d frames\n', synchFileAry(nWvLngths-i).name, nFramesTotalTemp);
    if i == 0; nFramesTotal = nFramesTotalTemp; end; 
    nFramesTotal = min([nFramesTotal nFramesTotalTemp]);
end
load([synchPath synchFileAry(1).name], 'frameArrivalTime', 'frameSynch'); % Set sequence 1 (red) = the main sequence

% YBS: correct for the fact that red's frame number may be larger than green's
fileSequence(end).last_frame = nFramesTotal;

% Truncate the frameSynch & frameArrivalTime to the same length
if(size(frameSynch,2)) > nFramesTotal   frameSynch(:,nFramesTotal+1:end) = [];   end
if(length(frameArrivalTime)) > nFramesTotal  frameArrivalTime(nFramesTotal+1:end) = [];  end

