classdef RegionOfInterest < hgsetget
  
  
  properties % IDENTICAL TO 'REGIONPROPS' PROPERTIES
	 Area
	 BoundingBox
	 Centroid
	 ConvexArea
	 ConvexHull
	 ConvexImage
	 Eccentricity
	 Image
	 Perimeter
	 PixelIdxList
	 PixelList
	 SubarrayIdx
	 MaxIntensity
	 MeanIntensity
	 MinIntensity
	 PixelValues
	 WeightedCentroid
  end
  properties (Dependent)
	 Mask
  end
  properties
	 LabelMatrix
	 FrameSize
  end
  properties
	 Frames
	 SubRegion
	 SuperRegion
	 NumberOfMerges = 0;
  end
  properties
	 isConfirmed = false
	 isCombined = false
	 isMerged = false
	 isOverlapping = false
	 isSubRegion = false
	 isSuperRegion = false
  end
  
  
  
  events
  end
  
  
  
  
  methods % CONSTRUCTOR & SETUP
	 function obj = RegionOfInterest(varargin)
		if nargin > 1	% Input is property-value pairs
		  for k = 1:2:length(varargin)
			 obj.(varargin{k}) = varargin{k+1};
		  end
		elseif nargin == 1 % Input is a multi-ROI BWFRAME structure with fields 'RegionProps' and 'bwMask'
		  % 		  for k=2:numel(bwvid), roi = cat(1,roi, RegionOfInterest(bwvid(k))); fprintf('Frame: %i\tAccumulating ROIs: %i\n',k,numel(roi)), end
		  bwRpInput = varargin{1};
		  if isfield(bwRpInput, 'RegionProps')
			 RP = bwRpInput.RegionProps;
		  elseif all(isfield(bwRpInput,{'Centroid','BoundingBox','PixelIdxList'}))
			 RP = bwRpInput;
		  end
		  if isfield(bwRpInput,'bwMask')
			 [RP.FrameSize] = deal(size(bwRpInput.bwMask));
		  end
		  if numel(RP) > 1
			 for nr = 1:size(RP,1)
				for nc = 1:size(RP,2)
				  obj(nr,nc) = RegionOfInterest(RP(nr,nc));
				end
			 end
		  else
			 % PROCESS INPUT
			 rpFields = fields(RP);
			 for kField = 1:numel(rpFields)
				fn = rpFields{kField};
				obj.(fn) = RP.(fn);
			 end
		  end
		end
	 end
	 function show(obj)
		persistent H
    persistent chan
		if numel(obj) > 1
       if isempty(chan) || chan >= 3
          chan = 1;
       else
          chan = chan+1;
       end
		  for k=1:numel(obj)
			 show(obj(k));
		  end
		else
		  cdata = uint8(obj.Mask);
      cdata(:,:,chan)
		  if isempty(H)
			 H.im = handle(imshow(repmat(cdata,1,1,3)));
			 H.ax = handle(gca);
			 H.fig = handle(gcf);
			 H.ax.DrawMode = 'fast';
		  else
			 try
				currData = H.im.CData;
				H.im.CData = cat(3,cdata, currData(:,:,1:2));
				drawnow
			 catch
				H = [];
				obj.show();
			 end
		  end
		end
	 end
  end
  methods % COMPARISON METHODS
	 function doesOverlap = overlaps(obj, roi)
		if numel(obj) > 1 || numel(roi) > 1
		  doesOverlap = false(numel(obj),numel(roi));
		  for kObj=1:numel(obj)
			 for kRoi=1:numel(roi)
				doesOverlap(kObj,kRoi) = overlaps(obj(kObj), roi(kRoi));
			 end
		  end
		else
		  doesOverlap = any(ismember(obj.PixelIdxList, roi.PixelIdxList));
		end
	 end
	 function idxOverlap = spatialOverlap(obj, roi)
		if numel(obj) > 1 || numel(roi) > 1
		  idxOverlap = zeros(numel(obj),numel(roi));
		  for kObj=1:numel(obj)
			 for kRoi=1:numel(roi)
				idxOverlap(kObj,kRoi) = spatialOverlap(obj(kObj), roi(kRoi));
			 end
		  end
		else
		  idxOverlap = intersect(obj.PixelIdxList, roi.PixelIdxList);
		end
	 end
	 function varargout = fractionalOverlap(obj, roi)
		% ovr = fractionalOverlap(obj, roi)
		% [ovr, rvo] = fractionalOverlap(obj, roi)
		% returns a fractional number (or two) indicating
		%	0:			'no-overlap'
		%	ovr:	'fraction of OBJ that overlaps with ROI relative to total OBJ area
		%	rvo:   'fraction of ROI that overlaps with OBJ relative to total ROI area
		if numel(obj) > 1 || numel(roi) > 1
		  oFracOverlap = zeros(numel(obj),numel(roi));
		  rFracOverlap = zeros(numel(obj),numel(roi));
		  for kObj=1:numel(obj)
			 for kRoi=1:numel(roi)
				[oFracOverlap(kObj,kRoi) , rFracOverlap(kObj,kRoi)] = fractionalOverlap(obj(kObj), roi(kRoi));
			 end
		  end
		else
		  oNpix = numel(obj.PixelIdxList);
		  rNpix = numel(roi.PixelIdxList);
		  try
			 idxOverlap = intersect(obj.PixelIdxList, roi.PixelIdxList);
		  catch me
			 disp(me.message)
			 keyboard
		  end
		  oFracOverlap = numel(idxOverlap)/oNpix;
		  rFracOverlap = numel(idxOverlap)/rNpix;
		end
		varargout{1} = oFracOverlap;
		if nargout > 1
		  varargout{2} = rFracOverlap;
		end
	 end
	 function isWithin = isInBoundingBox(obj, roi)
		if numel(obj) > 1 || numel(roi) > 1
		  isWithin = false(numel(obj),numel(roi));
		  for kObj=1:numel(obj)
			 for kRoi=1:numel(roi)
				isWithin(kObj,kRoi) = isInBoundingBox(obj(kObj), roi(kRoi));
			 end
		  end
		else
		  xc = obj.Centroid(1);
		  yc = obj.Centroid(2);
		  xbL = roi.BoundingBox(1);
		  xbR = xbL + roi.BoundingBox(3);
		  ybB = roi.BoundingBox(2);
		  ybT = ybB + roi.BoundingBox(4);
		  isWithin =  (xc >= xbL) & (xc <= xbR) & (yc >= ybB) & (yc <= ybT);
		end
	 end
	 function pxDist = centroidSeparation(obj, roi)
		if numel(obj) > 1 || numel(roi) > 1
		  pxDist = zeros(numel(obj),numel(roi));
		  for kObj=1:numel(obj)
			 for kRoi=1:numel(roi)
				pxDist(kObj,kRoi) = centroidSeparation(obj(kObj), roi(kRoi));
			 end
		  end
		else
		  xdist = obj.Centroid(1) - roi.Centroid(1);
		  ydist = obj.Centroid(2) - roi.Centroid(2);
		  pxDist = hypot( xdist, ydist);
		end
	 end
  end
  methods % COMPARISON/RELATION DEFINING FUNCTIONALITY OF BUILT-IN OPERATORS
	 function jd = eq(obj, roi)
		[ofor, rfoo] = fractionalOverlap(obj,roi);
		eqThresh = .95;
		jd =  (ofor >= eqThresh) & (rfoo >= eqThresh);
	 end
	 function jd = ne(obj, roi)
		jd =  ~eq(obj,roi);
	 end
	 function jd = lt(obj, roi)
		% a larger roi that entirely encompasses a smaller (sub-)roi is deemed 'greater'
		% ... note: the roi with a fractional overlap closer to one also necessarily smaller and therefore
		% 'less-than' the roi with the smaller fractional overlap
		[ofor, rfoo] = fractionalOverlap(obj,roi);
		jd = ofor > rfoo;
	 end
	 function jd = le(obj, roi)
		[ofor, rfoo] = fractionalOverlap(obj,roi);
		jd = ofor >= rfoo;
	 end
	 function jd = gt(obj, roi)
		[ofor, rfoo] = fractionalOverlap(obj,roi);
		jd = ofor < rfoo;
	 end
	 function jd = ge(obj, roi)
		[ofor, rfoo] = fractionalOverlap(obj,roi);
		jd =  ofor <= rfoo;
	 end
  end
  methods % COMBINATION/SUPBORDINATION METHODS
	 function obj = merge(obj, roi)
		% Returns single ROI (deletes the other)
		%TODO: perhaps add a function for and differentiate from 'combine(obj,roi)' ?
		mergeMask = or(obj.Mask,roi.Mask);
		rpMerge = regionprops(mergeMask,...
		  'Centroid', 'BoundingBox','Area',...
		  'Eccentricity', 'PixelIdxList');
		fn = fields(rpMerge);
		for kFn = 1:numel(fn)
		  fname = fn{kFn};
		  obj.(fname) = rpMerge.(fname);
		end
		obj.Frames = union(roi.Frames, obj.Frames);
		fn = properties(obj);
		for kFn = 1:numel(fn)
		  fname = fn{kFn};
		  if isempty(obj.(fname)) && ~isempty(roi.(fname))
			 obj.(fname) = roi.(fname);
		  elseif ~isempty(obj.(fname)) && ~isempty(roi.(fname))
			 % TODO
		  end
		end
		obj.NumberOfMerges = obj.NumberOfMerges + 1;
		obj.isMerged = true;
		% 		delete(roi);
	 end
	 function obj = addSubRoi(obj, roi)
		nSub = numel(obj.SubRegion)+1;
		obj.SubRegion(nSub) = roi;
		obj.isSuperRegion = true;
		roi.isSubRegion = true;
		%TODO: merge sub and super to make whole-super, (super-super?)?
	 end
	 function roi = add2SuperRoi(obj, roi)
		roi = addSubRoi(roi,obj);
	 end
	 function updateProperties(obj)
		%TODO: cycle through properties to uniformly keep up-to-date with sub-regions
	 end
	 function delete(obj)
		try
		  delete(obj.SubRegion)
		catch
		end
	 end
  end
  methods % GET DEPENDENT PROPERTIES
	 function mask = get.Mask(obj)
		pxIdx = cat(1,obj.PixelIdxList);
		if isempty(obj.FrameSize)
		  % assume square & power-of-2 frame size based on pixel indices
		  maxidx = max(pxIdx);
		  sqsize = 2.^(1:12);
		  framePow2 = find(sqsize > sqrt(maxidx),1,'first');
		  obj.FrameSize = [2^framePow2 2^framePow2];
		  warning('Assuming frame size')
		end
		mask = false(obj.FrameSize);
		mask(pxIdx) = true;
	 end
	 
  end
  
  
  
end















